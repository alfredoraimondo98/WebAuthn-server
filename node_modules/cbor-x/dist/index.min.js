(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.CBOR={}))})(this,function(e){"use strict";var t=Math.exp,s=Math.log,n=Math.round;function a(){try{let e=r();if(F){if(B>=F.postBundlePosition){let e=new Error("Unexpected bundle position");throw e.incomplete=!0,e}// bundled strings to skip past
B=F.postBundlePosition}if(B==V)// finished reading this source, cleanup references
T=null,x=null,Y&&(Y=null);else if(B>V){// over read
let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}else if(!X)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw R(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function r(){let e=x[B++],t=e>>5;if(e&=31,23<e)switch(e){case 24:e=x[B++];break;case 25:if(7==t)return p();e=W.getUint16(B),B+=2;break;case 26:if(7==t){let e=W.getFloat32(B);if(2<q.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let t=fe[(127&x[B])<<1|x[B+1]>>7];return B+=4,(t*e+(0<e?.5:-.5)>>0)/t}return B+=4,e}e=W.getUint32(B),B+=4;break;case 27:if(7==t){let e=W.getFloat64(B);return B+=8,e}if(1<t){if(0<W.getUint32(B))throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");e=W.getUint32(B+4)}else q.int64AsNumber?(e=4294967296*W.getUint32(B),e+=W.getUint32(B+4)):e=W.getBigUint64(B);B+=8;break;case 31:// indefinite length
switch(t){case 2:// byte string
case 3:// text string
throw new Error("Indefinite length not supported for byte or text strings");case 4:// array
let e,s=[],n=0;for(;(e=r())!=w;)s[n++]=e;return 4==t?s:3==t?s.join(""):Buffer.concat(s);case 5:// map
let a;if(q.mapsAsObjects){let e={};if(q.keyMap)for(;(a=r())!=w;)e[o(q.decodeKey(a))]=r();else for(;(a=r())!=w;)e[o(a)]=r();return e}else{z&&(q.mapsAsObjects=!0,z=!1);let e=new Map;if(q.keyMap)for(;(a=r())!=w;)e.set(q.decodeKey(a),r());else for(;(a=r())!=w;)e.set(a,r());return e}case 7:return w;default:throw new Error("Invalid major type for indefinite length "+t);}default:throw new Error("Unknown token "+e);}switch(t){case 0:// positive int
return e;case 1:// negative int
return~e;case 2:// buffer
return l(e);case 3:// string
if(H>=B)return K.slice(B-G,(B+=e)-G);if(0==H&&140>V&&32>e){// for small blocks, avoiding the overhead of the extract call is helpful
let t=16>e?c(e):u(e);if(null!=t)return t}return te(e);case 4:// array
let s=Array(e);//if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())	
//else 
for(let t=0;t<e;t++)s[t]=r();return s;case 5:// map
if(q.mapsAsObjects){let t={};if(q.keyMap)for(let s=0;s<e;s++)t[o(q.decodeKey(r()))]=r();else for(let s=0;s<e;s++)t[o(r())]=r();return t}else{z&&(q.mapsAsObjects=!0,z=!1);let t=new Map;if(q.keyMap)for(let s=0;s<e;s++)t.set(q.decodeKey(r()),r());else for(let s=0;s<e;s++)t.set(r(),r());return t}case 6:// extension
if(e>=D){let t=T[8191&e];// check record structures first
// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))
if(t)return t.read||(t.read=i(t)),t.read();if(65536>e){if(e==P)// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)
return oe(r());if(e==L){let e=m(),t=r();for(let s=2;s<e;s++)oe([t++,r()]);return r()}if(e==D)return y();if(q.getShared&&(b(),t=T[8191&e],t))return t.read||(t.read=i(t)),t.read()}}let n=J[e];if(n)return n.handlesRead?n(r):n(r());else{let t=r();for(let s,n=0;n<$.length;n++)if(s=$[n](e,t),void 0!==s)return s;return new ie(t,e)}case 7:// fixed value
switch(e){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;// undefined
case 31:default:let t=(N||g())[e];if(void 0!==t)return t;throw new Error("Unknown token "+e);}default:// negative int
if(isNaN(e)){let e=new Error("Unexpected end of CBOR data");throw e.incomplete=!0,e}throw new Error("Unknown CBOR token "+e);}}function i(e){function t(){// get the array size from the header
let e=x[B++];//let majorType = token >> 5
if(e&=31,23<e)switch(e){case 24:e=x[B++];break;case 25:e=W.getUint16(B),B+=2;break;case 26:e=W.getUint32(B),B+=4;break;default:throw new Error("Expected array header, but got "+x[B-1]);}// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
let t=this.compiledReader;// first look to see if we have the fast compiled function
for(;t;){// we have a fast compiled object literal reader
if(t.propertyCount===e)return t(r);// with the right length, so we use it
t=t.next}if(3<=this.slowReads++){// create a fast compiled reader
let s=this.length==e?this:this.slice(0,e);return t=q.keyMap?new Function("r","return {"+s.map(e=>q.decodeKey(e)).map(e=>ee.test(e)?o(e)+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"):new Function("r","return {"+s.map(e=>ee.test(e)?o(e)+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}"),this.compiledReader&&(t.next=this.compiledReader),t.propertyCount=e,this.compiledReader=t,t(r)}let s={};if(q.keyMap)for(let t=0;t<e;t++)s[o(q.decodeKey(this[t]))]=r();else for(let t=0;t<e;t++)s[o(this[t])]=r();return s}return e.slowReads=0,t}function o(e){return"__proto__"===e?"__proto_":e}function d(e){let t;if(16>e&&(t=c(e)))return t;if(64<e&&C)return C.decode(x.subarray(B,B+=e));const s=B+e,n=[];for(t="";B<s;){const e=x[B++];if(0==(128&e))n.push(e);else if(192==(224&e)){// 2 bytes
const t=63&x[B++];n.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&x[B++],s=63&x[B++];n.push((31&e)<<12|t<<6|s)}else if(240==(248&e)){// 4 bytes
const t=63&x[B++],s=63&x[B++],a=63&x[B++];let r=(7&e)<<18|t<<12|s<<6|a;65535<r&&(r-=65536,n.push(55296|1023&r>>>10),r=56320|1023&r),n.push(r)}else n.push(e);4096<=n.length&&(t+=se.apply(String,n),n.length=0)}return 0<n.length&&(t+=se.apply(String,n)),t}function u(e){let t=B,s=Array(e);for(let n=0;n<e;n++){const e=x[B++];if(0<(128&e))return void(B=t);s[n]=e}return se.apply(String,s)}function c(t){if(4>t){if(!(2>t)){let e=x[B++],s=x[B++];if(0<(128&e)||0<(128&s))return void(B-=2);if(3>t)return se(e,s);let n=x[B++];return 0<(128&n)?void(B-=3):se(e,s,n)}if(0===t)return"";else{let e=x[B++];return 1<(128&e)?void(B-=1):se(e)}}else{let s=x[B++],a=x[B++],r=x[B++],u=x[B++];if(0<(128&s)||0<(128&a)||0<(128&r)||0<(128&u))return void(B-=4);if(6>t){if(4===t)return se(s,a,r,u);else{let t=x[B++];return 0<(128&t)?void(B-=5):se(s,a,r,u,t)}}else if(8>t){let n=x[B++],e=x[B++];if(0<(128&n)||0<(128&e))return void(B-=6);if(7>t)return se(s,a,r,u,n,e);let i=x[B++];return 0<(128&i)?void(B-=7):se(s,a,r,u,n,e,i)}else{let d=x[B++],e=x[B++],c=x[B++],p=x[B++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&p))return void(B-=8);if(10>t){if(8===t)return se(s,a,r,u,d,e,c,p);else{let t=x[B++];return 0<(128&t)?void(B-=9):se(s,a,r,u,d,e,c,p,t)}}else if(12>t){let n=x[B++],i=x[B++];if(0<(128&n)||0<(128&i))return void(B-=10);if(11>t)return se(s,a,r,u,d,e,c,p,n,i);let o=x[B++];return 0<(128&o)?void(B-=11):se(s,a,r,u,d,e,c,p,n,i,o)}else{let f=x[B++],i=x[B++],g=x[B++],h=x[B++];if(0<(128&f)||0<(128&i)||0<(128&g)||0<(128&h))return void(B-=12);if(!(14>t)){let l=x[B++],y=x[B++];if(0<(128&l)||0<(128&y))return void(B-=14);if(15>t)return se(s,a,r,u,d,e,c,p,f,i,g,h,l,y);let n=x[B++];return 0<(128&n)?void(B-=15):se(s,a,r,u,d,e,c,p,f,i,g,h,l,y,n)}if(12===t)return se(s,a,r,u,d,e,c,p,f,i,g,h);else{let t=x[B++];return 0<(128&t)?void(B-=13):se(s,a,r,u,d,e,c,p,f,i,g,h,t)}}}}}function l(e){return q.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(x,B,B+=e):x.subarray(B,B+=e)}function p(){let e=x[B++],t=x[B++],s=(127&e)>>2;if(31===s)// specials
return t||3&e?NaN:128&e?-Infinity:1/0;if(0===s){// sub-normals
// significand with 10 fractional bits and divided by 2^14
let s=((3&e)<<8|t)/16777216;return 128&e?-s:s}return ae[3]=128&e|// sign bit
(s>>1)+56,ae[2]=(7&e)<<5|// last exponent bit and first two mantissa bits
t>>3,ae[1]=t<<5,ae[0]=0,ne[0]}function f(e,t){return"string"==typeof e?e+t:e instanceof Array?e.concat(t):Object.assign({},e,t)}function g(){if(!N)if(q.getShared)b();else throw new Error("No packed values available");return N}function h(e,t){let s="get"+e.name.slice(0,-5);"function"!=typeof e&&(e=null);let n=e.BYTES_PER_ELEMENT;for(let a=0;2>a;a++){if(!a&&1==n)continue;let r=2==n?1:4==n?2:3;J[a?t:t-4]=1==n||a==ce?s=>{if(!e)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new e(Uint8Array.prototype.slice.call(s,0).buffer)}:n=>{if(!e)throw new Error("Could not find typed array for code "+t);let o=new DataView(n.buffer,n.byteOffset,n.byteLength),d=n.length>>r,u=new e(d),c=o[s];for(let e=0;e<d;e++)u[e]=c.call(o,e<<r,a);return u}}}function y(){let e=m(),t=B+r();for(let t,s=2;s<e;s++)// skip past bundles that were already read
// this will increment position, so must add to position afterwards
t=m(),B+=t;let s=B;return B=t,F=[d(m()),d(m())],F.position0=0,F.position1=0,F.postBundlePosition=B,B=s,r()}function m(){let e=31&x[B++];return 23<e&&(24===e?e=x[B++]:25===e?(e=W.getUint16(B),B+=2):26===e?(e=W.getUint32(B),B+=4):void 0),e}function b(){if(q.getShared){let e=k(()=>(x=null,q.getShared()))||{},t=e.structures||[];q.sharedVersion=e.version,N=q.sharedValues=e.packedValues,!0===T?q.structures=T=t:T.splice.apply(T,[0,t.length].concat(t))}}function k(e){let t=V,s=B,n=G,a=H,r=K,i=Y,o=F,d=new Uint8Array(x.slice(0,V)),u=T,c=q,l=X,p=e();return V=t,B=s,G=n,H=a,K=r,Y=i,F=o,x=d,X=l,T=u,q=c,W=new DataView(x.buffer,x.byteOffset,x.byteLength),p}function R(){x=null,Y=null,T=null}function O(e){J[e.tag]=e.decode}function M(e){24>e?Ue[Ae++]=128|e:256>e?(Ue[Ae++]=152,Ue[Ae++]=e):65536>e?(Ue[Ae++]=153,Ue[Ae++]=e>>8,Ue[Ae++]=255&e):(Ue[Ae++]=154,ve.setUint32(Ae,e),Ae+=4)}function _(e,t){switch(typeof e){case"string":if(3<e.length){if(-1<t.objectMap[e]||t.values.length>=t.maxValues)return;let s=t.get(e);if(s)2==++s.count&&t.values.push(e);else if(t.set(e,{count:1}),t.samplingPackedValues){let s=t.samplingPackedValues.get(e);s?s.count++:t.samplingPackedValues.set(e,{count:1})}}break;case"object":if(e)if(e instanceof Array)for(let s=0,n=e.length;s<n;s++)_(e[s],t);else{let n=!t.encoder.useRecords;for(var s in e)e.hasOwnProperty(s)&&(n&&_(s,t),_(e[s],t))}break;case"function":console.log(e);}}function S(e,t){// the big endian equivalents are 4 less
return!Pe&&1<t&&(e-=4),{tag:e,encode:function s(e,t){let n=e.byteLength,a=e.byteOffset||0,r=e.buffer||e;t(Oe?Buffer.from(r,a,n):new Uint8Array(r,a,n))}}}function E(e,t){let s=e.byteLength;// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,
// must wrap it to set it.
24>s?Ue[Ae++]=64+s:256>s?(Ue[Ae++]=88,Ue[Ae++]=s):65536>s?(Ue[Ae++]=89,Ue[Ae++]=s>>8,Ue[Ae++]=255&s):(Ue[Ae++]=90,ve.setUint32(Ae,s),Ae+=4),Ae+s>=Ue.length&&t(Ae+s),Ue.set(e.buffer?e:new Uint8Array(e),Ae),Ae+=s}function U(e,t){// insert the ids that need to be referenced for structured clones
let s,n=2*t.length,a=e.length-n;t.sort((e,t)=>e.offset>t.offset?1:-1);for(let s,n=0;n<t.length;n++){s=t[n],s.id=n;for(let t of s.references)e[t++]=n>>8,e[t]=255&n}for(;s=t.pop();){let t=s.offset;e.copyWithin(t+n,t,a),n-=2;let r=t+n;// http://cbor.schmorp.de/value-sharing
e[r++]=216,e[r++]=28,a=t}return e}function v(e,t){ve.setUint32(Ce.position+e,Ae-Ce.position-e+1);// the offset to bundle
let s=Ce;Ce=null,t(s[0]),t(s[1])}function*I(e,t){const s=new Be(t);for(const n of e)yield s.encode(n)}async function*A(e,t){const s=new Be(t);for await(const n of e)yield s.encode(n)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - Decoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */let C;try{C=new TextDecoder}catch(e){}let x,V,B=0;const L=57342,P=57343,D=57337,j=6,w={};let T,K,F,Y,N,W,z,q={},G=0,H=0,J=[],$=[],Q={useRecords:!1,mapsAsObjects:!0},X=!1;class Z{constructor(e){if(e&&((e.keyMap||e._keyMap)&&!e.useRecords&&(e.useRecords=!1,e.mapsAsObjects=!0),!1===e.useRecords&&void 0===e.mapsAsObjects&&(e.mapsAsObjects=!0),e.getStructures&&(e.getShared=e.getStructures),e.getShared&&!e.structures&&((e.structures=[]).uninitialized=!0),e.keyMap))// this is what we use to denote an uninitialized structures
{this.mapKey=new Map;for(let[t,s]of Object.entries(e.keyMap))this.mapKey.set(s,t)}Object.assign(this,e)}/*
		decodeKey(key) {
			return this.keyMap
				? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
				: key
		}
		*/decodeKey(e){return this.keyMap?this.mapKey.get(e)||e:e}encodeKey(e){return this.keyMap&&this.keyMap.hasOwnProperty(e)?this.keyMap[e]:e}encodeKeys(e){if(!this._keyMap)return e;let t=new Map;for(let[s,n]of Object.entries(e))t.set(this._keyMap.hasOwnProperty(s)?this._keyMap[s]:s,n);return t}decodeKeys(e){if(!this._keyMap||"Map"!=e.constructor.name)return e;if(!this._mapKey){this._mapKey=new Map;for(let[e,t]of Object.entries(this._keyMap))this._mapKey.set(t,e)}let t={};//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)
return e.forEach((e,s)=>t[o(this._mapKey.has(s)?this._mapKey.get(s):s)]=e),t}mapDecode(e,t){let s=this.decode(e);if(this._keyMap)//Experiemntal support for Optimised KeyMap  decoding 
switch(s.constructor.name){case"Array":return s.map(e=>this.decodeKeys(e));//case 'Map': return this.decodeKeys(res)
}return s}decode(e,t){if(x)// re-entrant execution, save the state and restore it after we do this decode
return k(()=>(R(),this?this.decode(e,t):Z.prototype.decode.call(Q,e,t)));V=-1<t?t:e.length,B=0,H=0,K=null,F=null,x=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{W=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(x=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof Z){if(q=this,N=this.sharedValues&&(this.pack?Array(this.maxPrivatePackedValues||16).concat(this.sharedValues):this.sharedValues),this.structures)return T=this.structures,a();(!T||0<T.length)&&(T=[])}else q=Q,(!T||0<T.length)&&(T=[]),N=null;return a()}decodeMultiple(e,t){let s,n=0;try{let r=e.length;X=!0;let i=this?this.decode(e,r):ge.decode(e,r);if(t){if(!1===t(i))return;for(;B<r;)if(n=B,!1===t(a()))return}else{for(s=[i];B<r;)n=B,s.push(a());return s}}catch(e){throw e.lastPosition=n,e.values=s,e}finally{X=!1,R()}}}const ee=/^[a-zA-Z_$][a-zA-Z\d_$]*$/;let te=d,se=String.fromCharCode,ne=new Float32Array(1),ae=new Uint8Array(ne.buffer,0,4),re=Array(4096);class ie{constructor(e,t){this.value=e,this.tag=t}}J[0]=e=>new Date(e),J[1]=e=>new Date(n(1e3*e)),J[2]=e=>{// bigint extension
let t=BigInt(0);for(let s=0,n=e.byteLength;s<n;s++)t=BigInt(e[s])+t<<BigInt(8);return t},J[3]=e=>BigInt(-1)-J[2](e),J[4]=e=>+(e[1]+"e"+e[0]),J[5]=e=>e[1]*t(e[0]*s(2));// the registration of the record definition extension
const oe=e=>{let t=e[0]-57344,s=e[1],n=T[t];n&&n.isShared&&((T.restoreStructures||(T.restoreStructures=[]))[t]=n),T[t]=s,s.read=i(s);let a={};if(q.keyMap)for(let t,n=2,r=e.length;n<r;n++)t=q.decodeKey(s[n-2]),a[o(t)]=e[n];else for(let t,n=2,r=e.length;n<r;n++)t=s[n-2],a[o(t)]=e[n];return a};J[105]=oe,J[14]=e=>F?F[0].slice(F.position0,F.position0+=e):new ie(e,14),J[15]=e=>F?F[1].slice(F.position1,F.position1+=e):new ie(e,15);let de={Error,RegExp};J[27]=e=>(de[e[0]]||Error)(e[1],e[2]);const ue=e=>{if(132!=x[B++])throw new Error("Packed values structure must be followed by a 4 element array");let t=e();// packed values
return N=N?t.concat(N.slice(t.length)):t,N.prefixes=e(),N.suffixes=e(),e();// read the rump
};ue.handlesRead=!0,J[51]=ue,J[j]=e=>{// packed reference
if(!N)if(q.getShared)b();else return new ie(e,j);if("number"==typeof e)return N[16+(0<=e?2*e:-2*e-1)];throw new Error("No support for non-integer packed references yet")},J[25]=e=>stringRefs[e],J[256]=e=>{stringRefs=[];try{return e()}finally{stringRefs=null}},J[256].handlesRead=!0,J[28]=e=>{Y||(Y=new Map,Y.id=0);let t,s=Y.id++,n=x[B];t=4==n>>5?[]:{};let a={target:t};// a placeholder object
Y.set(s,a);let r=e();// read the next value as the target object to id
return a.used?Object.assign(t,r):(a.target=r,r);// no cycle, can just use the returned read object
},J[28].handlesRead=!0,J[29]=e=>{// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)
let t=Y.get(e);return t.used=!0,t.target},J[258]=e=>new Set(e),(J[259]=e=>(q.mapsAsObjects&&(q.mapsAsObjects=!1,z=!0),e())).handlesRead=!0;$.push((e,t)=>225<=e&&255>=e?f(g().prefixes[e-224],t):28704<=e&&32767>=e?f(g().prefixes[e-28672],t):1879052288<=e&&2147483647>=e?f(g().prefixes[e-1879048192],t):216<=e&&223>=e?f(t,g().suffixes[e-216]):27647<=e&&28671>=e?f(t,g().suffixes[e-27639]):1811940352<=e&&1879048191>=e?f(t,g().suffixes[e-1811939328]):e==1399353956?{packedValues:N,structures:T.slice(0),version:t}:55799==e?t:void 0);const ce=1==new Uint8Array(new Uint16Array([1]).buffer)[0],le=[Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,"undefined"==typeof BigUint64Array?{name:"BigUint64Array"}:BigUint64Array,Int8Array,Int16Array,Int32Array,"undefined"==typeof BigInt64Array?{name:"BigInt64Array"}:BigInt64Array,Float32Array,Float64Array],pe=[64,68,69,70,71,72,77,78,79,85,86];for(let t=0;t<le.length;t++)h(le[t],pe[t]);const fe=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let t=0;256>t;t++)fe[t]=+("1e"+Math.floor(45.15-.30103*t));let ge=new Z({useRecords:!1});const he=ge.decode,ye=ge.decodeMultiple,me={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let be;try{be=new TextEncoder}catch(e){}let ke,Re;const Oe="undefined"!=typeof Buffer,Me=Oe?Buffer.allocUnsafeSlow:Uint8Array,_e=Oe?Buffer:Uint8Array,Se=256,Ee=Oe?4294967296:2144337920;let Ue,ve,Ie,Ae=0,Ce=null;const xe=/[\u0080-\uFFFF]/,Ve=Symbol("record-id");class Be extends Z{constructor(e){super(e),this.offset=0;let t,s,a,r,i;e=e||{};let o=_e.prototype.utf8Write?function(e,t,s){return Ue.utf8Write(e,t,s)}:!!(be&&be.encodeInto)&&function(e,t){return be.encodeInto(e,Ue.subarray(t)).written},d=this,u=e.structures||e.saveStructures,c=e.maxSharedStructures;if(null==c&&(c=u?128:0),8190<c)throw new Error("Maximum maxSharedStructure is 8190");let l=e.sequential;l&&(c=0),this.structures||(this.structures=[]),this.saveStructures&&(this.saveShared=this.saveStructures);let p,f,g,h=e.sharedValues;if(h){g=Object.create(null);for(let e=0,t=h.length;e<t;e++)g[h[e]]=e}let y=[],m=0,b=0;this.mapEncode=function(e,t){// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)
if(this._keyMap&&!this._mapped)//console.log('encoding ', value)
switch(e.constructor.name){case"Array":e=e.map(e=>this.encodeKeys(e));//case 'Map': 
//	value = this.encodeKeys(value)
//	break
}//this._mapped = true
return this.encode(e,t)},this.encode=function(n,o){if(Ue||(Ue=new Me(8192),ve=new DataView(Ue.buffer,0,8192),Ae=0),Ie=Ue.length-10,2048>Ie-Ae?(Ue=new Me(Ue.length),ve=new DataView(Ue.buffer,0,Ue.length),Ie=Ue.length-10,Ae=0):o===Ye&&(Ae=2147483640&Ae+7),t=Ae,d.useSelfDescribedHeader&&(ve.setUint32(Ae,3654940416),Ae+=3),i=d.structuredClone?new Map:null,d.bundleStrings&&"string"!=typeof n?(Ce=[],Ce.size=1/0):Ce=null,s=d.structures,s){if(s.uninitialized){let e=d.getShared()||{};d.structures=s=e.structures||[],d.sharedVersion=e.version;let t=d.sharedValues=e.packedValues;if(t){g={};for(let e=0,s=t.length;e<s;e++)g[t[e]]=e}}let e=s.length;if(e>c&&!l&&(e=c),!s.transitions){s.transitions=Object.create(null);for(let t,n=0;n<e;n++){//console.log('shared struct keys:', keys)
if(t=s[n],!t)continue;let e,a=s.transitions;for(let s=0,r=t.length;s<r;s++){void 0===a[Ve]&&(a[Ve]=n);let r=t[s];e=a[r],e||(e=a[r]=Object.create(null)),a=e}a[Ve]=1048576|n}}l||(s.nextId=e)}if(a&&(a=!1),r=s||[],f=g,e.pack){let t=new Map;if(t.values=[],t.encoder=d,t.maxValues=e.maxPrivatePackedValues||(g?16:1/0),t.objectMap=g||!1,t.samplingPackedValues=p,_(n,t),0<t.values.length){Ue[Ae++]=216,Ue[Ae++]=51,M(4);let e=t.values;k(e),M(0),M(0),f=Object.create(g||null);for(let t=0,s=e.length;t<s;t++)f[e[t]]=t}}try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(k(n),Ce&&v(t,k),d.offset=Ae,i&&i.idsToInsert){Ae+=2*i.idsToInsert.length,Ae>Ie&&O(Ae),d.offset=Ae;let e=U(Ue.subarray(t,Ae),i.idsToInsert);return i=null,e}return o&Ye?(Ue.start=t,Ue.end=Ae,Ue):Ue.subarray(t,Ae);// position can change if we call encode again in saveShared, so we get the buffer now
}finally{if(s)if(10>b&&b++,s.length>c&&(s.length=c),1e4<m)s.transitions=null,b=0,m=0,0<y.length&&(y=[]);else if(0<y.length&&!l){for(let e=0,t=y.length;e<t;e++)y[e][Ve]=void 0;y=[]}if(a&&d.saveShared){d.structures.length>c&&(d.structures=d.structures.slice(0,c));// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let e=Ue.subarray(t,Ae);return!1===d.updateSharedData()?d.encode(n):e;// re-encode if it fails
}o&Ne&&(Ae=t)}},this.findCommonStringsToPack=()=>(p=new Map,g||(g=Object.create(null)),e=>{let t=e&&e.threshold||4,s=this.pack?e.maxPrivatePackedValues||16:0;h||(h=this.sharedValues=[]);for(let[n,r]of p)r.count>t&&(g[n]=s++,h.push(n),a=!0);for(;this.saveShared&&!1===this.updateSharedData(););p=null});const k=s=>{Ae>Ie&&(Ue=O(Ae));var n,a=typeof s;if("string"==a){if(f){let t=f[s];if(0<=t)return void(16>t?Ue[Ae++]=t+224:(Ue[Ae++]=198,1&t?k(15-t>>1):k(t-16>>1)));/*						} else if (packedStatus.serializationId != serializationId) {
								packedStatus.serializationId = serializationId
								packedStatus.count = 1
								if (options.sharedPack) {
									let sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1
									if (shareCount > (options.sharedPack.threshold || 5)) {
										let sharedPosition = packedStatus.position = packedStatus.nextSharedPosition
										hasSharedUpdate = true
										if (sharedPosition < 16)
											target[position++] = sharedPosition + 0xc0

									}
								}
							} // else any in-doc incrementation?*/if(p&&!e.pack){let e=p.get(s);e?e.count++:p.set(s,{count:1})}}let a=s.length;if(Ce&&4<=a&&1024>a){if((Ce.size+=a)>61440){let e,s=(Ce[0]?3*Ce[0].length+Ce[1].length:0)+10;Ae+s>Ie&&(Ue=O(Ae+s)),Ue[Ae++]=217,Ue[Ae++]=223,Ue[Ae++]=249,Ue[Ae++]=Ce.position?132:130,Ue[Ae++]=26,e=Ae-t,Ae+=4,Ce.position&&v(t,k),Ce=["",""],Ce.size=0,Ce.position=e}let e=xe.test(s);return Ce[e?0:1]+=s,Ue[Ae++]=e?206:207,void k(a)}let r;// first we estimate the header size, so we can write to the correct location
r=32>a?1:256>a?2:65536>a?3:5;let i=3*a;if(Ae+i>Ie&&(Ue=O(Ae+i)),64>a||!o){let e,t,i,o=Ae+r;for(e=0;e<a;e++)t=s.charCodeAt(e),128>t?Ue[o++]=t:2048>t?(Ue[o++]=192|t>>6,Ue[o++]=128|63&t):55296==(64512&t)&&56320==(64512&(i=s.charCodeAt(e+1)))?(t=65536+((1023&t)<<10)+(1023&i),e++,Ue[o++]=240|t>>18,Ue[o++]=128|63&t>>12,Ue[o++]=128|63&t>>6,Ue[o++]=128|63&t):(Ue[o++]=224|t>>12,Ue[o++]=128|63&t>>6,Ue[o++]=128|63&t);n=o-Ae-r}else n=o(s,Ae+r,i);24>n?Ue[Ae++]=96|n:256>n?(2>r&&Ue.copyWithin(Ae+2,Ae+1,Ae+1+n),Ue[Ae++]=120,Ue[Ae++]=n):65536>n?(3>r&&Ue.copyWithin(Ae+3,Ae+2,Ae+2+n),Ue[Ae++]=121,Ue[Ae++]=n>>8,Ue[Ae++]=255&n):(5>r&&Ue.copyWithin(Ae+5,Ae+3,Ae+3+n),Ue[Ae++]=122,ve.setUint32(Ae,n),Ae+=4),Ae+=n}else if("number"===a){if(s>>>0===s)24>s?Ue[Ae++]=s:256>s?(Ue[Ae++]=24,Ue[Ae++]=s):65536>s?(Ue[Ae++]=25,Ue[Ae++]=s>>8,Ue[Ae++]=255&s):(Ue[Ae++]=26,ve.setUint32(Ae,s),Ae+=4);else if(s>>0===s)-24<=s?Ue[Ae++]=31-s:-256<=s?(Ue[Ae++]=56,Ue[Ae++]=~s):-65536<=s?(Ue[Ae++]=57,ve.setUint16(Ae,~s),Ae+=2):(Ue[Ae++]=58,ve.setUint32(Ae,~s),Ae+=4);else{let e;if(0<(e=this.useFloat32)&&4294967296>s&&-2147483648<=s){Ue[Ae++]=250,ve.setFloat32(Ae,s);let t;if(4>e||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(t=s*fe[(127&Ue[Ae])<<1|Ue[Ae+1]>>7])>>0===t)return void(Ae+=4);// move back into position for writing a double
Ae--}Ue[Ae++]=251,ve.setFloat64(Ae,s),Ae+=8}}else if("object"===a){if(!s)Ue[Ae++]=246;else{if(i){let e=i.get(s);if(e){// 16-bit uint
if(Ue[Ae++]=216,Ue[Ae++]=29,Ue[Ae++]=25,!e.references){let t=i.idsToInsert||(i.idsToInsert=[]);e.references=[],t.push(e)}// TODO: also support 32-bit
return e.references.push(Ae-t),void(Ae+=2)}i.set(s,{offset:Ae-t})}let e=s.constructor;if(e===Object)R(s,!0);else if(e===Array){n=s.length,24>n?Ue[Ae++]=128|n:M(n);for(let e=0;e<n;e++)k(s[e])}else if(e!==Map){for(let e,t=0,n=ke.length;t<n;t++)if(e=Re[t],s instanceof e){let e=ke[t],n=e.tag;return null==n&&(n=e.getTag&&e.getTag.call(this,s)),24>n?Ue[Ae++]=192|n:256>n?(Ue[Ae++]=216,Ue[Ae++]=n):65536>n?(Ue[Ae++]=217,Ue[Ae++]=n>>8,Ue[Ae++]=255&n):-1<n&&(Ue[Ae++]=218,ve.setUint32(Ae,n),Ae+=4),void e.encode.call(this,s,k,O)}if(s[Symbol.iterator]){Ue[Ae++]=159;// indefinite length array
for(let e of s)k(e);// stop-code
return void(Ue[Ae++]=255)}// no extension found, write as object
R(s,!s.hasOwnProperty)}else if((this.mapsAsObjects?!1!==this.useTag259ForMaps:this.useTag259ForMaps)&&(Ue[Ae++]=217,Ue[Ae++]=1,Ue[Ae++]=3),n=s.size,24>n?Ue[Ae++]=160|n:256>n?(Ue[Ae++]=184,Ue[Ae++]=n):65536>n?(Ue[Ae++]=185,Ue[Ae++]=n>>8,Ue[Ae++]=255&n):(Ue[Ae++]=186,ve.setUint32(Ae,n),Ae+=4),d.keyMap)for(let[e,t]of s)k(d.encodeKey(e)),k(t);else for(let[e,t]of s)k(e),k(t)}}else if("boolean"===a)Ue[Ae++]=s?245:244;else if("bigint"===a){if(s<BigInt(1)<<BigInt(64)&&0<=s)Ue[Ae++]=27,ve.setBigUint64(Ae,s);else if(s>-(BigInt(1)<<BigInt(64))&&0>s)Ue[Ae++]=59,ve.setBigUint64(Ae,-s-BigInt(1));else// overflow
if(this.largeBigIntToFloat)Ue[Ae++]=251,ve.setFloat64(Ae,+s);else throw new RangeError(s+" was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");Ae+=8}else if("undefined"===a)Ue[Ae++]=247;else throw new Error("Unknown type: "+a)},R=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),s=Object.values(e),n=t.length;if(24>n?Ue[Ae++]=160|n:256>n?(Ue[Ae++]=184,Ue[Ae++]=n):65536>n?(Ue[Ae++]=185,Ue[Ae++]=n>>8,Ue[Ae++]=255&n):(Ue[Ae++]=186,ve.setUint32(Ae,n),Ae+=4),d.keyMap)for(let e=0;e<n;e++)k(encodeKey(t[e])),k(s[e]);else for(let e=0;e<n;e++)k(t[e]),k(s[e])}:(e,s)=>{Ue[Ae++]=185;// always use map 16, so we can preallocate and set the length afterwards
let n=Ae-t;Ae+=2;let a=0;if(d.keyMap)for(let t in e)(s||e.hasOwnProperty(t))&&(k(d.encodeKey(t)),k(e[t]),a++);else for(let t in e)(s||e.hasOwnProperty(t))&&(k(t),k(e[t]),a++);Ue[n++ +t]=a>>8,Ue[n+t]=255&a}:(e,t)=>{let s,n,o,d=r.transitions||(r.transitions=Object.create(null)),u=0,l=0;if(this.keyMap){o=Object.keys(e).map(e=>this.encodeKey(e)),l=o.length;for(let e,t=0;t<l;t++)e=o[t],s=d[e],s||(s=d[e]=Object.create(null),u++),d=s}else for(let a in e)(t||e.hasOwnProperty(a))&&(s=d[a],s||(1048576&d[Ve]&&(n=65535&d[Ve]),s=d[a]=Object.create(null),u++),d=s,l++);let p=d[Ve];if(void 0!==p)p&=65535,Ue[Ae++]=217,Ue[Ae++]=224|p>>8,Ue[Ae++]=255&p;else if(o||(o=d.__keys__||(d.__keys__=Object.keys(e))),void 0===n?(p=r.nextId++,!p&&(p=0,r.nextId=1),p>=Se&&(r.nextId=(p=c)+1)):p=n,r[p]=o,p<c){Ue[Ae++]=217,Ue[Ae++]=224|p>>8,Ue[Ae++]=255&p,d=r.transitions;for(let e=0;e<l;e++)(void 0===d[Ve]||1048576&d[Ve])&&(d[Ve]=p),d=d[o[e]];d[Ve]=1048576|p,a=!0}else{d[Ve]=p,ve.setUint32(Ae,3655335680),Ae+=3,u&&(m+=b*u),y.length>=Se-c&&(y.shift()[Ve]=void 0),y.push(d),M(l+2),k(57344+p),k(o);for(let t of Object.values(e))k(t);return}for(let s in 24>l?Ue[Ae++]=128|l:M(l),e)(t||e.hasOwnProperty(s))&&k(e[s])},O=e=>{var s=Math.min,a=Math.max;let r;if(16777216<e){// special handling for really large buffers
if(e-t>Ee)throw new Error("Encoded buffer would be larger than maximum buffer size");r=s(Ee,4096*n(a((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
r=(a(e-t<<2,Ue.length-1)>>12)+1<<12;let i=new Me(r);return ve=new DataView(i.buffer,0,r),Ue.copy?Ue.copy(i,0,t,e):i.set(Ue.slice(t,e)),Ae-=t,t=0,Ie=i.length-10,Ue=i}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
Ue=e,ve=new DataView(Ue.buffer,Ue.byteOffset,Ue.byteLength),Ae=0}clearSharedData(){this.structures&&(this.structures=[]),this.sharedValues&&(this.sharedValues=void 0)}updateSharedData(){let e=this.sharedVersion||0;this.sharedVersion=e+1;let t=this.structures.slice(0),s=new Le(t,this.sharedValues,this.sharedVersion),n=this.saveShared(s,t=>(t&&t.version||0)==e);// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data
return!1===n?(s=this.getShared()||{},this.structures=s.structures||[],this.sharedValues=s.packedValues,this.sharedVersion=s.version,this.structures.nextId=this.structures.length):t.forEach((e,t)=>this.structures[t]=e),n}}class Le{constructor(e,t,s){this.structures=e,this.packedValues=t,this.version=s}}const Pe=1==new Uint8Array(new Uint16Array([1]).buffer)[0];Re=[Date,Set,Error,RegExp,ie,ArrayBuffer,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,"undefined"==typeof BigUint64Array?function(){}:BigUint64Array,Int8Array,Int16Array,Int32Array,"undefined"==typeof BigInt64Array?function(){}:BigInt64Array,Float32Array,Float64Array,Le],ke=[{// Date
tag:1,encode(e,t){let s=e.getTime()/1e3;(this.useTimestamp32||0===e.getMilliseconds())&&0<=s&&4294967296>s?(Ue[Ae++]=26,ve.setUint32(Ae,s),Ae+=4):(Ue[Ae++]=251,ve.setFloat64(Ae,s),Ae+=8)}},{// Set
tag:258,// https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
encode(e,t){let s=Array.from(e);t(s)}},{// Error
tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t([e.name,e.message])}},{// RegExp
tag:27,// http://cbor.schmorp.de/generic-object
encode(e,t){t(["RegExp",e.source,e.flags])}},{// Tag
getTag(e){return e.tag},encode(e,t){t(e.value)}},{// ArrayBuffer
encode(e,t,s){E(e,s)}},{// Uint8Array
getTag(e){if(e.constructor===Uint8Array&&(this.tagUint8Array||Oe&&!1!==this.tagUint8Array))return 64;// else no tag
},encode(e,t,s){E(e,s)}},S(68,1),S(69,2),S(70,4),S(71,8),S(72,1),S(77,2),S(78,4),S(79,8),S(85,4),S(86,8),{encode(e,t){// write SharedData
let s=e.packedValues||[],n=e.structures||[];if(0<s.values.length){Ue[Ae++]=216,Ue[Ae++]=51,M(4);let e=s.values;t(e),M(0),M(0),packedObjectMap=Object.create(sharedPackedObjectMap||null);for(let t=0,s=e.length;t<s;t++)packedObjectMap[e[t]]=t}if(n){ve.setUint32(Ae,3655335424),Ae+=3;let s=n.slice(0);s.unshift(57344),s.push(new ie(e.version,1399353956)),t(s)}else t(new ie(e.version,1399353956))}}];let De=new Be({useRecords:!1});const je=De.encode,{NEVER:we,ALWAYS:Te,DECIMAL_ROUND:Ke,DECIMAL_FIT:Fe}=me,Ye=512,Ne=1024;e.ALWAYS=Te,e.DECIMAL_FIT=Fe,e.DECIMAL_ROUND=Ke,e.Decoder=Z,e.Encoder=Be,e.FLOAT32_OPTIONS=me,e.NEVER=we,e.REUSE_BUFFER_MODE=Ye,e.Tag=ie,e.addExtension=function t(e){if(e.Class){if(!e.encode)throw new Error("Extension has no encode function");Re.unshift(e.Class),ke.unshift(e)}O(e)},e.clearSource=R,e.decode=he,e.decodeIter=function s(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new Z(t);let a;const r=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
a&&(e=Buffer.concat([a,e]),a=void 0);try{t=n.decodeMultiple(e)}catch(s){if(s.incomplete)a=e.slice(s.lastPosition),t=s.values;else throw s}return t};if("function"==typeof e[Symbol.iterator])return function*t(){for(const t of e)yield*r(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*t(){for await(const t of e)yield*r(t)}():void 0},e.decodeMultiple=ye,e.encode=je,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is encoded as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - cbor-x Encoder options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function s(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return I(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return A(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.roundFloat32=function t(e){ne[0]=e;let s=fe[(127&ae[3])<<1|ae[2]>>7];return(s*e+(0<e?.5:-.5)>>0)/s},Object.defineProperty(e,"__esModule",{value:!0})});
